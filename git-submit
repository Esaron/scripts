#!/bin/bash

for ((i = 1; i <= $#; i++)); do
  if [ $i -eq "-f" ]
  then
    force=true
  else
    workitem=$i
  fi
done

remote=$(git config --get submit.remote)
current=$(git rev-parse --symbolic-full-name --abbrev-ref HEAD)
upstream=$(git rev-parse --symbolic-full-name --abbrev-ref @{u})
parent=${upstream#*/} # trim the leading remote name portion
num_submit=$(git rev-list @{u}.. | wc -l)

_gen_ChangeIdInput() {
  echo "tree `git write-tree`"
  if parent=`git rev-parse "HEAD^0" 2>/dev/null`
  then
    echo "parent $parent"
  fi
  echo "author `git var GIT_AUTHOR_IDENT`"
  echo "committer `git var GIT_COMMITTER_IDENT`"
  echo
  printf '%s' "$clean_message"
}
_gen_ChangeId() {
  _gen_ChangeIdInput |
  git hash-object -t commit --stdin
}

if [ -z "$remote" ]
then
  echo "submit.remote is not set"
  exit 1
fi

if [ -z "$parent" ]
then
  echo "can not determine upstream of current branch"
  exit 1
fi

if [ "$num_submit" -eq 0 ]
then
  echo "nothing found to submit between $current and $upstream"
  exit 0
elif [[ "$num_submit" -ne 1 && !$force ]]
then
  echo "can only submit a single commit, found $num_submit"
  exit 1
fi

target="$parent"
git pull
if [ "$parent" != "$current" ]
then
  target="$target/$current"
  git push "$remote" HEAD:refs/for/$target
else
  if [ -z $workitem ]
  then
    workitem=`_gen_ChangeId`
  fi
  git branch -m $workitem && git push "$remote" HEAD:refs/for/$target
fi
git branch -vv
